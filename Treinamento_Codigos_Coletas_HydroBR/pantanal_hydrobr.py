# -*- coding: utf-8 -*-
"""CÃ³pia de Pantanal_HydroBR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ni1sIFZ5ahkhn-59yqsagaf3kOcbP7_B

#  Projeto de CiÃªncia de Dados

# Modelagem, DetecÃ§Ã£o e PrediÃ§Ã£o dos Ciclos HidrolÃ³gicos do Pantanal

---

##  1. ContextualizaÃ§Ã£o

O **Pantanal** Ã© a maior planÃ­cie alagÃ¡vel tropical do planeta, com regime hidrolÃ³gico altamente sazonal.

A alternÃ¢ncia entre **cheias e secas** impacta:

* ðŸŒ± Biodiversidade
* ðŸš¢ NavegaÃ§Ã£o
* ðŸŒ¾ Agricultura
* ðŸ’§ SeguranÃ§a hÃ­drica
* ðŸ’° Economia regional

MudanÃ§as recentes levantam hipÃ³teses sobre possÃ­vel alteraÃ§Ã£o estrutural no regime hidrolÃ³gico.

---

##  2. Problema de Pesquisa

### Pergunta Central

> Qual Ã© a dinÃ¢mica, frequÃªncia, intensidade, espacializaÃ§Ã£o e tendÃªncia dos ciclos de cheias e secas no Pantanal ao longo das Ãºltimas dÃ©cadas?

### SubquestÃµes

* HÃ¡ mudanÃ§a estrutural no regime hidrolÃ³gico?
* Eventos extremos estÃ£o se intensificando?
* Ã‰ possÃ­vel prever cheias e secas com modelos estatÃ­sticos e Deep Learning?
* Existem padrÃµes distintos entre municÃ­pios?

---

##  3. Ãrea de Estudo

###  Mato Grosso (MT)

* BarÃ£o de MelgaÃ§o
* CÃ¡ceres
* Lambari dâ€™Oeste
* PoconÃ©
* Nossa Senhora do Livramento
* Santo AntÃ´nio do Leverger
* Itiquira

###  Mato Grosso do Sul (MS)

* CorumbÃ¡
* LadÃ¡rio
* Aquidauana
* Miranda
* Bodoquena
* Porto Murtinho
* Rio Verde de Mato Grosso
* Sonora
* Coxim

### ðŸ”Ž Total

* 16 municÃ­pios
* 7 em MT
* 9 em MS

MunicÃ­pios com maior Ã¡rea no Pantanal:

* BarÃ£o de MelgaÃ§o (MT)
* CorumbÃ¡ (MS)

---

##  4. Fonte de Dados

Os dados serÃ£o obtidos via pacote **HydroBR**, com acesso estruturado Ã s bases da
**AgÃªncia Nacional de Ãguas**.

### VariÃ¡veis disponÃ­veis

* Cota (nÃ­vel do rio)
* VazÃ£o
* PrecipitaÃ§Ã£o
* Metadados das estaÃ§Ãµes

### CritÃ©rios de seleÃ§Ã£o

* EstaÃ§Ãµes em MT e MS
* SÃ©ries histÃ³ricas longas
* ConsistÃªncia temporal

---

#  5. Metodologia AnalÃ­tica

---

## 5.1 Coleta Automatizada

* SeleÃ§Ã£o automatizada de estaÃ§Ãµes
* Download programÃ¡tico
* ConsolidaÃ§Ã£o em DataFrame Ãºnico
* PadronizaÃ§Ã£o do Ã­ndice temporal

---

## 5.2 PrÃ©-processamento

### ðŸ”¹ Tratamento

* InterpolaÃ§Ã£o temporal
* RemoÃ§Ã£o de outliers (IQR / Z-score)
* VerificaÃ§Ã£o de consistÃªncia

### ðŸ”¹ Engenharia de VariÃ¡veis

* Anomalias hidrolÃ³gicas
* MÃ©dias mÃ³veis
* PadronizaÃ§Ã£o (z-score)
* ClassificaÃ§Ã£o automÃ¡tica:

| Classe         | CritÃ©rio       |
| -------------- | -------------- |
| Cheia extrema  | > Percentil 95 |
| Cheia moderada | 90â€“95          |
| Normal         | 10â€“90          |
| Seca           | 5â€“10           |
| Seca extrema   | < 5            |

---

## 5.3 AnÃ¡lise ExploratÃ³ria (EDA)

### EstatÃ­sticas Descritivas

* MÃ©dia
* Desvio padrÃ£o
* Assimetria
* Curtose
* Quantis extremos

### VisualizaÃ§Ãµes

* SÃ©ries histÃ³ricas completas
* ComparaÃ§Ã£o por dÃ©cadas
* Heatmap anual
* Boxplots sazonais

### DependÃªncia Temporal

* ACF
* PACF

### DecomposiÃ§Ã£o STL

* TendÃªncia
* Sazonalidade
* ResÃ­duo

---

## 5.4 AnÃ¡lise Espectral â€“ ExtraÃ§Ã£o de Ciclos

AplicaÃ§Ã£o da Transformada RÃ¡pida de Fourier (FFT):

[
FFT(x_t)
]

### Objetivos

* Identificar periodicidade dominante
* Detectar ciclos interanuais
* Avaliar mudanÃ§as na frequÃªncia dominante
* Identificar ciclos de seca prolongada

### TÃ©cnicas complementares

* Periodograma
* Densidade espectral
* Filtro passa-banda
* Wavelet (anÃ¡lise multiescalar)

---

## 5.5 Modelagem de SÃ©ries Temporais

###  Modelos EstatÃ­sticos

* ARIMA
* SARIMA
* SARIMAX (com precipitaÃ§Ã£o exÃ³gena)

### MÃ©tricas

* AIC
* BIC
* RMSE
* Cross-validation temporal

---

###  Modelos de Deep Learning

* LSTM
* Transformer para SÃ©ries Temporais

### Objetivos

* PrevisÃ£o de cheias futuras
* AntecipaÃ§Ã£o de eventos extremos
* ComparaÃ§Ã£o com modelos clÃ¡ssicos

---

## 5.6 DetecÃ§Ã£o de Eventos Extremos

### CritÃ©rios

* Percentil 90â€“95 â†’ Cheia
* Percentil 5â€“10 â†’ Seca
* DuraÃ§Ã£o mÃ­nima consecutiva
* Intensidade acumulada

### VisualizaÃ§Ãµes

* GrÃ¡fico tipo Gantt
* Curvas de severidade
* Ranking histÃ³rico

---

## 5.7 AnÃ¡lise de TendÃªncia e MudanÃ§a Estrutural

* Teste de Mann-Kendall
* RegressÃ£o linear robusta
* Theil-Sen
* Change Point Detection

### Objetivos

* Detectar intensificaÃ§Ã£o de secas
* Avaliar aumento da variabilidade
* Identificar alteraÃ§Ãµes no regime sazonal

---

## 5.8 VisualizaÃ§Ã£o Interativa

### Mapas

* EstaÃ§Ãµes georreferenciadas
* ClassificaÃ§Ã£o por intensidade
* Timeline animada

### Ferramentas

* Folium
* Plotly
* GeoPandas

---

## 5.9 ExportaÃ§Ã£o

* Excel (.xlsx)
* CSV
* RelatÃ³rio PDF
* Download direto no Colab

---

#  6. Estrutura do Notebook

```
01 - InstalaÃ§Ã£o de Pacotes
02 - Coleta de Dados
03 - PrÃ©-processamento
04 - AnÃ¡lise ExploratÃ³ria
05 - AnÃ¡lise Espectral (FFT)
06 - Modelagem SARIMA
07 - Modelagem LSTM / Transformer
08 - Eventos Extremos
09 - Mapas Interativos
10 - ExportaÃ§Ã£o
```

---

#  7. Resultados Esperados

* âœ” Periodicidade dominante dos ciclos
* âœ” IdentificaÃ§Ã£o de ciclos interanuais
* âœ” DuraÃ§Ã£o mÃ©dia das cheias
* âœ” TendÃªncia estatisticamente significativa (ou nÃ£o)
* âœ” Modelo preditivo validado
* âœ” Dashboard interativo
* âœ” Base exportÃ¡vel para pesquisas futuras

---

#  8. ContribuiÃ§Ãµes CientÃ­ficas

* IntegraÃ§Ã£o entre hidrologia e ciÃªncia de dados
* FFT + SARIMA + Transformers no mesmo pipeline
* DetecÃ§Ã£o automÃ¡tica de eventos extremos
* AnÃ¡lise multiescalar (dias, meses, anos)
* Pipeline totalmente reprodutÃ­vel

## **1ï¸âƒ£ InstalaÃ§Ã£o de pacotes e configuraÃ§Ã£o inicial**
* `pandas` â†’ manipulaÃ§Ã£o de DataFrames
* `numpy` â†’ operaÃ§Ãµes matemÃ¡ticas
* `hydrobr.get_data` â†’ pacote que acessa dados da **ANA** (AgÃªncia Nacional de Ãguas)
* `tqdm.notebook` â†’ barra de progresso visual no Colab durante downloads grandes
"""



# InstalaÃ§Ã£o de Bibliotecas
!pip install hydrobr # Acesso e download de dados hidrolÃ³gicos da ANA (Hidroweb) de forma automatizada
!pip install pymannkendall # Testes estatÃ­sticos de tendÃªncia em sÃ©ries temporais (ex.: Mann-Kendall)
!pip install statsmodels #anÃ¡lise estatÃ­stica avanÃ§ada e modelagem estatÃ­stica
!pip install openpyxl #leitura e escrita de arquivos Excel (.xlsx)
!pip install tqdm #barras de progresso para loops e tarefas demoradas
!pip install seaborn #criaÃ§Ã£o de grÃ¡ficos estatÃ­sticos bonitos e simples

# Imports


import pandas as pd
import numpy as np
from hydrobr import get_data
from tqdm.notebook import tqdm

# Lista todas as estaÃ§Ãµes de precipitaÃ§Ã£o disponÃ­veis
lista_estacoes_precipitacao = get_data.ANA.list_prec_stations()
print("Total de estaÃ§Ãµes:", lista_estacoes_precipitacao.shape[0])

# Exibir as 20 primeiras
lista_estacoes_precipitacao.head(20)

cidade = "Campo Grande"
filtro = lista_estacoes_precipitacao[
    lista_estacoes_precipitacao["City"].str.upper() == cidade.upper()
]

print(f"EstaÃ§Ãµes encontradas em {cidade}:")
filtro

cidade_parcial = "Miran"
filtro_parcial = lista_estacoes_precipitacao[
    lista_estacoes_precipitacao["City"].str.contains(cidade_parcial, case=False, na=False)
]

print("EstaÃ§Ãµes com nome que contÃ©m:", cidade_parcial)
filtro_parcial

# 2 Coleta de Dados - Lista de municÃ­pios do Pantanal e normalizaÃ§Ã£o
# Lista oficial de municÃ­pios pantaneiros
municipios_pantanal = [
    "BARÃƒO DE MELGAÃ‡O","CÃCERES","LAMBARI Dâ€™OESTE","POCONÃ‰",
    "NOSSA SENHORA DO LIVRAMENTO","SANTO ANTÃ”NIO DO LEVERGER","ITIQUIRA",
    "CORUMBÃ","LADÃRIO","AQUIDAUANA","MIRANDA","BODOQUENA",
    "PORTO MURTINHO","RIO VERDE DE MATO GROSSO","SONORA","COXIM",
    # "Porto EsperidiÃ£o", #vinculada a regiÃ£o Pantaneira
    # "Porto Estrela", #vinculada a regiÃ£o Pantaneira"
]

# Normalizar texto para evitar problemas com acentos e maiÃºsculas/minÃºsculas
lista_estacoes_precipitacao["City_norm"] = (
    lista_estacoes_precipitacao["City"]
    .str.upper()
    .str.normalize('NFKD')
    .str.encode('ascii', errors='ignore')
    .str.decode('utf-8')
)

municipios_norm = [
    m.upper().encode('ascii', errors='ignore').decode('utf-8')
    for m in municipios_pantanal
]

# Filtrar apenas as estaÃ§Ãµes do Pantanal
estacoes_pantanal = lista_estacoes_precipitacao[
    lista_estacoes_precipitacao["City_norm"].isin(municipios_norm)
]

print("EstaÃ§Ãµes encontradas nas cidades do Pantanal:", estacoes_pantanal.shape[0])
estacoes_pantanal

# Listar de todos os mÃ©todos disponÃ­veis para ANA
dir(get_data.ANA)

# VerificaÃ§Ã£o da documentaÃ§Ã£o dentro do Colab:
help(get_data.ANA)

"""list_flow_stations() Ã© o mÃ©todo correto para listar estaÃ§Ãµes de vazÃ£o.

flow_data() recebe uma lista de cÃ³digos mesmo que seja sÃ³ um cÃ³digo por vez.

Normalizamos os nomes das cidades (City_norm) para filtrar apenas os municÃ­pios pantaneiros.

Consolidamos todas as sÃ©ries em um DataFrame Ãºnico (df_flu_all), pronto para anÃ¡lise.
"""

# -------------------------------
# ImportaÃ§Ãµes
# -------------------------------
import pandas as pd
import numpy as np
from hydrobr import get_data
from tqdm.notebook import tqdm
import unicodedata

# -------------------------------
# 1ï¸âƒ£ Lista oficial de municÃ­pios do Pantanal
# -------------------------------
municipios_pantanal = [
    "BARÃƒO DE MELGAÃ‡O","CÃCERES","LAMBARI Dâ€™OESTE","POCONÃ‰",
    "NOSSA SENHORA DO LIVRAMENTO","SANTO ANTÃ”NIO DO LEVERGER","ITIQUIRA",
    "CORUMBÃ","LADÃRIO","AQUIDAUANA","MIRANDA","BODOQUENA",
    "PORTO MURTINHO","RIO VERDE DE MATO GROSSO","SONORA","COXIM"
]

# FunÃ§Ã£o de normalizaÃ§Ã£o de texto
# def normalize_txt(txt):
#    return txt.upper().normalize('NFKD').encode('ascii', errors='ignore').decode('utf-8')

def normalize_txt(txt):
    # Garantir que txt Ã© string
    txt = str(txt)
    # Normalizar acentos
    txt = unicodedata.normalize('NFKD', txt)
    # Remover caracteres nÃ£o ASCII e converter para maiÃºsculas
    txt = txt.encode('ascii', errors='ignore').decode('utf-8').upper()
    return txt


# Normalizar lista de municÃ­pios
municipios_norm = [normalize_txt(m) for m in municipios_pantanal]
print(municipios_norm)

# -------------------------------
# 2ï¸âƒ£ EstaÃ§Ãµes de precipitaÃ§Ã£o
# -------------------------------
lista_prec = get_data.ANA.list_prec_stations()  # todas as estaÃ§Ãµes de precipitaÃ§Ã£o
lista_prec["City_norm"] = lista_prec["City"].apply(normalize_txt)

# Filtrar apenas municÃ­pios do Pantanal
estacoes_prec_pantanal = lista_prec[lista_prec["City_norm"].isin(municipios_norm)].copy()
print("EstaÃ§Ãµes de precipitaÃ§Ã£o no Pantanal:", estacoes_prec_pantanal.shape[0])

# Baixar sÃ©ries de precipitaÃ§Ã£o
dados_prec = {}
for codigo in tqdm(estacoes_prec_pantanal["Code"].astype(str), desc="Baixando precipitaÃ§Ã£o"):
    try:
        df = get_data.ANA.prec_data([codigo], only_consisted=False)  # recebe lista
        df.index = pd.to_datetime(df.index)  # padronizar Ã­ndice temporal
        dados_prec[codigo] = df
    except Exception as e:
        print(f"Erro ao baixar {codigo}: {e}")

# Consolidar todas as sÃ©ries em um Ãºnico DataFrame
df_prec_all = pd.concat(dados_prec.values(), keys=dados_prec.keys(), names=["Code", "Date"])
df_prec_all.reset_index(inplace=True)

# -------------------------------
# 3ï¸âƒ£ EstaÃ§Ãµes de vazÃ£o (flow)
# -------------------------------
lista_flu = get_data.ANA.list_flow_stations()  # mÃ©todo correto
lista_flu["City_norm"] = lista_flu["City"].apply(normalize_txt)

# Filtrar municÃ­pios do Pantanal
estacoes_flu_pantanal = lista_flu[lista_flu["City_norm"].isin(municipios_norm)].copy()
codigos_flu = estacoes_flu_pantanal["Code"].astype(str).tolist()
print("EstaÃ§Ãµes de vazÃ£o no Pantanal:", len(codigos_flu))

# Baixar sÃ©ries de vazÃ£o
dados_flu = {}
for codigo in tqdm(codigos_flu, desc="Baixando vazÃ£o"):
    try:
        df = get_data.ANA.flow_data([codigo], only_consisted=False)  # recebe lista de cÃ³digos
        df.index = pd.to_datetime(df.index)
        dados_flu[codigo] = df
    except Exception as e:
        print(f"Erro ao baixar {codigo}: {e}")

# Consolidar em Ãºnico DataFrame
df_flu_all = pd.concat(dados_flu.values(), keys=dados_flu.keys(), names=["Code", "Date"])
df_flu_all.reset_index(inplace=True)

# -------------------------------
# 4ï¸âƒ£ VisualizaÃ§Ã£o inicial
# -------------------------------
print("PrÃ©-visualizaÃ§Ã£o - PrecipitaÃ§Ã£o")
display(df_prec_all.head())

print("PrÃ©-visualizaÃ§Ã£o - VazÃ£o")
display(df_flu_all.head())

# -------------------------------
# ImportaÃ§Ãµes
# -------------------------------
import pandas as pd
import numpy as np
from hydrobr import get_data
from tqdm.notebook import tqdm
import unicodedata
from scipy.stats import zscore
import os

# Criar pasta de exportaÃ§Ã£o
if not os.path.exists("export"):
    os.makedirs("export")

# -------------------------------
# FunÃ§Ã£o de normalizaÃ§Ã£o de texto
# -------------------------------
def normalize_txt(txt):
    txt = str(txt)
    txt = unicodedata.normalize('NFKD', txt)
    txt = txt.encode('ascii', errors='ignore').decode('utf-8').upper()
    return txt

# -------------------------------
# Lista oficial de municÃ­pios do Pantanal
# -------------------------------
municipios_pantanal = [
    "BARÃƒO DE MELGAÃ‡O","CÃCERES","LAMBARI Dâ€™OESTE","POCONÃ‰",
    "NOSSA SENHORA DO LIVRAMENTO","SANTO ANTÃ”NIO DO LEVERGER","ITIQUIRA",
    "CORUMBÃ","LADÃRIO","AQUIDAUANA","MIRANDA","BODOQUENA",
    "PORTO MURTINHO","RIO VERDE DE MATO GROSSO","SONORA","COXIM"
]
municipios_norm = [normalize_txt(m) for m in municipios_pantanal]

# -------------------------------
# 1ï¸âƒ£ EstaÃ§Ãµes de precipitaÃ§Ã£o
# -------------------------------
lista_prec = get_data.ANA.list_prec_stations()
lista_prec["City_norm"] = lista_prec["City"].apply(normalize_txt)
estacoes_prec_pantanal = lista_prec[lista_prec["City_norm"].isin(municipios_norm)].copy()
print("EstaÃ§Ãµes de precipitaÃ§Ã£o no Pantanal:", estacoes_prec_pantanal.shape[0])

# Baixar sÃ©ries de precipitaÃ§Ã£o
dados_prec = {}
for codigo in tqdm(estacoes_prec_pantanal["Code"].astype(str), desc="Baixando precipitaÃ§Ã£o"):
    try:
        df = get_data.ANA.prec_data([codigo], only_consisted=False)
        df.index = pd.to_datetime(df.index)
        if not df.empty:
            # InterpolaÃ§Ã£o linear para valores faltantes
            df = df.interpolate(method='time').fillna(method='bfill').fillna(method='ffill')
            # Z-score
            df_z = df.apply(zscore)
            df_z.columns = [f"{c}_zscore" for c in df_z.columns]
            # Percentis para cheias/secas
            df_perc = df.rank(pct=True)
            df_perc.columns = [f"{c}_percentile" for c in df_perc.columns]
            # Concatenar normal, zscore e percentis
            df_final = pd.concat([df, df_z, df_perc], axis=1)
            dados_prec[codigo] = df_final
    except Exception as e:
        print(f"Erro ao baixar {codigo}: {e}")

# Concatenar todas as sÃ©ries de precipitaÃ§Ã£o
dfs_validos = [df for df in dados_prec.values() if not df.empty]
df_prec_all = pd.concat(dfs_validos, keys=dados_prec.keys(), names=["Code", "Date"])
df_prec_all.reset_index(inplace=True)

# Exportar para Excel
df_prec_all.to_excel("export/precipitacao_pantanal.xlsx", index=False)
print("âœ… PrecipitaÃ§Ã£o exportada para export/precipitacao_pantanal.xlsx")

# -------------------------------
# 2ï¸âƒ£ EstaÃ§Ãµes de vazÃ£o (flow)
# -------------------------------
lista_flu = get_data.ANA.list_flow_stations()
lista_flu["City_norm"] = lista_flu["City"].apply(normalize_txt)
estacoes_flu_pantanal = lista_flu[lista_flu["City_norm"].isin(municipios_norm)].copy()
codigos_flu = estacoes_flu_pantanal["Code"].astype(str).tolist()
print("EstaÃ§Ãµes de vazÃ£o no Pantanal:", len(codigos_flu))

dados_flu = {}
for codigo in tqdm(codigos_flu, desc="Baixando vazÃ£o"):
    try:
        df = get_data.ANA.flow_data([codigo], only_consisted=False)
        df.index = pd.to_datetime(df.index)
        if not df.empty:
            # InterpolaÃ§Ã£o linear para valores faltantes
            df = df.interpolate(method='time').fillna(method='bfill').fillna(method='ffill')
            # Z-score
            df_z = df.apply(zscore)
            df_z.columns = [f"{c}_zscore" for c in df_z.columns]
            # Percentis para cheias/secas
            df_perc = df.rank(pct=True)
            df_perc.columns = [f"{c}_percentile" for c in df_perc.columns]
            # Concatenar normal, zscore e percentis
            df_final = pd.concat([df, df_z, df_perc], axis=1)
            dados_flu[codigo] = df_final
    except Exception as e:
        print(f"Erro ao baixar {codigo}: {e}")

# Concatenar todas as sÃ©ries de vazÃ£o
dfs_validos_flu = [df for df in dados_flu.values() if not df.empty]
df_flu_all = pd.concat(dfs_validos_flu, keys=dados_flu.keys(), names=["Code", "Date"])
df_flu_all.reset_index(inplace=True)

# Exportar para Excel
df_flu_all.to_excel("export/vazao_pantanal.xlsx", index=False)
print("âœ… VazÃ£o exportada para export/vazao_pantanal.xlsx")

"""FunÃ§Ã£o preprocess_df:

Filtra DataFrames vazios

Interpola dados faltantes

Calcula STL (trend, seasonal, resid)

Calcula z-score e percentis

FunÃ§Ã£o export_dfs_to_excel:

Exporta mÃºltiplos DataFrames em um Ãºnico arquivo Excel

Divide em vÃ¡rias planilhas se ultrapassar 1 milhÃ£o de linhas

Limita nomes das abas a 31 caracteres

Substitui a exportaÃ§Ã£o direta to_excel pelo pipeline robusto acima

MantÃ©m a estrutura de download das estaÃ§Ãµes de precipitaÃ§Ã£o e vazÃ£o
"""

# -------------------------------
# ImportaÃ§Ãµes
# -------------------------------
import pandas as pd
import numpy as np
from hydrobr import get_data
from tqdm.notebook import tqdm
import unicodedata
from scipy.stats import zscore
from statsmodels.tsa.seasonal import STL
import math
import os

# Criar pasta de exportaÃ§Ã£o
EXPORT_PATH = "export"
if not os.path.exists(EXPORT_PATH):
    os.makedirs(EXPORT_PATH)

# -------------------------------
# FunÃ§Ã£o de normalizaÃ§Ã£o de texto
# -------------------------------
def normalize_txt(txt):
    txt = str(txt)
    txt = unicodedata.normalize('NFKD', txt)
    txt = txt.encode('ascii', errors='ignore').decode('utf-8').upper()
    return txt

# -------------------------------
# Lista oficial de municÃ­pios do Pantanal
# -------------------------------
municipios_pantanal = [
    "BARÃƒO DE MELGAÃ‡O","CÃCERES","LAMBARI Dâ€™OESTE","POCONÃ‰",
    "NOSSA SENHORA DO LIVRAMENTO","SANTO ANTÃ”NIO DO LEVERGER","ITIQUIRA",
    "CORUMBÃ","LADÃRIO","AQUIDAUANA","MIRANDA","BODOQUENA",
    "PORTO MURTINHO","RIO VERDE DE MATO GROSSO","SONORA","COXIM"
]
municipios_norm = [normalize_txt(m) for m in municipios_pantanal]

# -------------------------------
# FunÃ§Ãµes de prÃ©-processamento
# -------------------------------
def preprocess_df(df, value_cols=None):
    """Filtra vazio, interpola, calcula STL, z-score e percentis"""
    if df.empty:
        return None

    df = df.sort_index().copy()

    if value_cols is None:
        value_cols = df.columns.tolist()

    # InterpolaÃ§Ã£o temporal
    df[value_cols] = df[value_cols].interpolate(method='time', limit_direction='both')

    # STL
    for col in value_cols:
        stl = STL(df[col], period=12, robust=True)
        res = stl.fit()
        df[f"{col}_trend"] = res.trend
        df[f"{col}_seasonal"] = res.seasonal
        df[f"{col}_resid"] = res.resid

    # Z-score
    df_z = df[value_cols].apply(zscore)
    df_z.columns = [f"{c}_zscore" for c in df_z.columns]

    # Percentis
    df_perc = df[value_cols].rank(pct=True)
    df_perc.columns = [f"{c}_percentile" for c in df_perc.columns]

    df_final = pd.concat([df, df_z, df_perc], axis=1)
    return df_final

def export_dfs_to_excel(dfs_dict, filename, max_rows=1_000_000):
    """Exporta mÃºltiplos DataFrames em um Ãºnico Excel, dividindo em planilhas se necessÃ¡rio"""
    full_path = os.path.join(EXPORT_PATH, filename)
    with pd.ExcelWriter(full_path, engine="openpyxl") as writer:
        for station, df in dfs_dict.items():
            if df is None or df.empty:
                print(f"âš ï¸ {station}: DataFrame vazio, pulando exportaÃ§Ã£o")
                continue
            num_sheets = math.ceil(len(df) / max_rows)
            for i in range(num_sheets):
                start = i * max_rows
                end = (i + 1) * max_rows
                sheet_name = f"{station}" if num_sheets == 1 else f"{station}_{i+1}"
                sheet_name = sheet_name[:31]  # limite de 31 caracteres
                df.iloc[start:end].to_excel(writer, sheet_name=sheet_name, index=True)
    print(f"âœ… ExportaÃ§Ã£o concluÃ­da em '{full_path}'")

# -------------------------------
# 1ï¸âƒ£ EstaÃ§Ãµes de precipitaÃ§Ã£o
# -------------------------------
lista_prec = get_data.ANA.list_prec_stations()
lista_prec["City_norm"] = lista_prec["City"].apply(normalize_txt)
estacoes_prec_pantanal = lista_prec[lista_prec["City_norm"].isin(municipios_norm)].copy()
print("EstaÃ§Ãµes de precipitaÃ§Ã£o no Pantanal:", estacoes_prec_pantanal.shape[0])

dados_prec = {}
for codigo in tqdm(estacoes_prec_pantanal["Code"].astype(str), desc="Baixando precipitaÃ§Ã£o"):
    try:
        df = get_data.ANA.prec_data([codigo], only_consisted=False)
        df.index = pd.to_datetime(df.index)
        if not df.empty:
            df_proc = preprocess_df(df)
            dados_prec[codigo] = df_proc
    except Exception as e:
        print(f"Erro ao baixar {codigo}: {e}")

# Exportar todas as estaÃ§Ãµes de precipitaÃ§Ã£o em um Ãºnico Excel
export_dfs_to_excel(dados_prec, "precipitacao_pantanal.xlsx")

# -------------------------------
# 2ï¸âƒ£ EstaÃ§Ãµes de vazÃ£o
# -------------------------------
lista_flu = get_data.ANA.list_flow_stations()
lista_flu["City_norm"] = lista_flu["City"].apply(normalize_txt)
estacoes_flu_pantanal = lista_flu[lista_flu["City_norm"].isin(municipios_norm)].copy()
codigos_flu = estacoes_flu_pantanal["Code"].astype(str).tolist()
print("EstaÃ§Ãµes de vazÃ£o no Pantanal:", len(codigos_flu))

dados_flu = {}
for codigo in tqdm(codigos_flu, desc="Baixando vazÃ£o"):
    try:
        df = get_data.ANA.flow_data([codigo], only_consisted=False)
        df.index = pd.to_datetime(df.index)
        if not df.empty:
            df_proc = preprocess_df(df)
            dados_flu[codigo] = df_proc
    except Exception as e:
        print(f"Erro ao baixar {codigo}: {e}")

# Exportar todas as estaÃ§Ãµes de vazÃ£o em um Ãºnico Excel
export_dfs_to_excel(dados_flu, "vazao_pantanal.xlsx")